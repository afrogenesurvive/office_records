{"ast":null,"code":"/*\n * MIT LICENSE\n * Copyright (c) 2011 Devon Govett\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nconst fs = require('fs');\n\nconst zlib = require('zlib');\n\nmodule.exports = class PNG {\n  static decode(path, fn) {\n    return fs.readFile(path, function (err, file) {\n      const png = new PNG(file);\n      return png.decode(pixels => fn(pixels));\n    });\n  }\n\n  static load(path) {\n    const file = fs.readFileSync(path);\n    return new PNG(file);\n  }\n\n  constructor(data) {\n    let i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      const chunkSize = this.readUInt32();\n      let section = '';\n\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n\n              break;\n\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n\n  read(bytes) {\n    const result = new Array(bytes);\n\n    for (let i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n\n    return result;\n  }\n\n  readUInt32() {\n    const b1 = this.data[this.pos++] << 24;\n    const b2 = this.data[this.pos++] << 16;\n    const b3 = this.data[this.pos++] << 8;\n    const b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  }\n\n  readUInt16() {\n    const b1 = this.data[this.pos++] << 8;\n    const b2 = this.data[this.pos++];\n    return b1 | b2;\n  }\n\n  decodePixels(fn) {\n    return zlib.inflate(this.imgData, (err, data) => {\n      if (err) {\n        throw err;\n      }\n\n      const width = this.width,\n            height = this.height;\n      const pixelBytes = this.pixelBitlength / 8;\n      const pixels = new Buffer(width * height * pixelBytes);\n      const length = data.length;\n      let pos = 0;\n\n      function pass(x0, y0, dx, dy, singlePass = false) {\n        const w = Math.ceil((width - x0) / dx);\n        const h = Math.ceil((height - y0) / dy);\n        const scanlineLength = pixelBytes * w;\n        const buffer = singlePass ? pixels : new Buffer(scanlineLength * h);\n        let row = 0;\n        let c = 0;\n\n        while (row < h && pos < length) {\n          var byte, col, i, left, upper;\n\n          switch (data[pos++]) {\n            case 0:\n              // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n\n              break;\n\n            case 1:\n              // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n\n              break;\n\n            case 2:\n              // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (upper + byte) % 256;\n              }\n\n              break;\n\n            case 3:\n              // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n\n              break;\n\n            case 4:\n              // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n\n                const p = left + upper - upperLeft;\n                const pa = Math.abs(p - left);\n                const pb = Math.abs(p - upper);\n                const pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                buffer[c++] = (byte + paeth) % 256;\n              }\n\n              break;\n\n            default:\n              throw new Error(`Invalid filter algorithm: ${data[pos - 1]}`);\n          }\n\n          if (!singlePass) {\n            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            let bufferPos = row * scanlineLength;\n\n            for (i = 0; i < w; i++) {\n              for (let j = 0; j < pixelBytes; j++) pixels[pixelsPos++] = buffer[bufferPos++];\n\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n\n          row++;\n        }\n      }\n\n      if (this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n\n        pass(4, 0, 8, 8); // 2\n\n        pass(0, 4, 4, 8); // 3\n\n        pass(2, 0, 4, 4); // 4\n\n        pass(0, 2, 2, 4); // 5\n\n        pass(1, 0, 2, 2); // 6\n\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n\n      return fn(pixels);\n    });\n  }\n\n  decodePalette() {\n    const palette = this.palette;\n    const length = palette.length;\n    const transparency = this.transparency.indexed || [];\n    const ret = new Buffer(transparency.length + length);\n    let pos = 0;\n    let c = 0;\n\n    for (let i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n\n    return ret;\n  }\n\n  copyToImageData(imageData, pixels) {\n    let j, k;\n    let colors = this.colors;\n    let palette = null;\n    let alpha = this.hasAlphaChannel;\n\n    if (this.palette.length) {\n      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n\n    const data = imageData.data || imageData;\n    const length = data.length;\n    const input = palette || pixels;\n    let i = j = 0;\n\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        const v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  }\n\n  decode(fn) {\n    const ret = new Buffer(this.width * this.height * 4);\n    return this.decodePixels(pixels => {\n      this.copyToImageData(ret, pixels);\n      return fn(ret);\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/pedrojacob/Downloads/AMR/websites/office_records/ENT_EMR/frontend/node_modules/png-js/png-node.js"],"names":["fs","require","zlib","module","exports","PNG","decode","path","fn","readFile","err","file","png","pixels","load","readFileSync","constructor","data","i","pos","palette","imgData","transparency","text","chunkSize","readUInt32","section","String","fromCharCode","width","height","bits","colorType","compressionMethod","filterMethod","interlaceMethod","read","push","indexed","short","length","grayscale","rgb","index","indexOf","key","apply","slice","colors","hasAlphaChannel","includes","pixelBitlength","colorSpace","Buffer","Error","bytes","result","Array","b1","b2","b3","b4","readUInt16","decodePixels","inflate","pixelBytes","pass","x0","y0","dx","dy","singlePass","w","Math","ceil","h","scanlineLength","buffer","row","c","byte","col","left","upper","floor","paeth","upperLeft","p","pa","abs","pb","pc","pixelsPos","bufferPos","j","decodePalette","ret","copyToImageData","imageData","k","alpha","_decodedPalette","input","v"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;AAoBA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AAEAE,MAAM,CAACC,OAAP,GAAiB,MAAMC,GAAN,CAAU;AACzB,SAAOC,MAAP,CAAcC,IAAd,EAAoBC,EAApB,EAAwB;AACtB,WAAOR,EAAE,CAACS,QAAH,CAAYF,IAAZ,EAAkB,UAASG,GAAT,EAAcC,IAAd,EAAoB;AAC3C,YAAMC,GAAG,GAAG,IAAIP,GAAJ,CAAQM,IAAR,CAAZ;AACA,aAAOC,GAAG,CAACN,MAAJ,CAAWO,MAAM,IAAIL,EAAE,CAACK,MAAD,CAAvB,CAAP;AACD,KAHM,CAAP;AAID;;AAED,SAAOC,IAAP,CAAYP,IAAZ,EAAkB;AAChB,UAAMI,IAAI,GAAGX,EAAE,CAACe,YAAH,CAAgBR,IAAhB,CAAb;AACA,WAAO,IAAIF,GAAJ,CAAQM,IAAR,CAAP;AACD;;AAEDK,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChB,QAAIC,CAAJ;AACA,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKE,GAAL,GAAW,CAAX,CAHgB,CAGF;;AAEd,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,IAAL,GAAY,EAAZ;;AAEA,WAAO,IAAP,EAAa;AACX,YAAMC,SAAS,GAAG,KAAKC,UAAL,EAAlB;AACA,UAAIC,OAAO,GAAG,EAAd;;AACA,WAAKR,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,CAAhB,EAAmBA,CAAC,EAApB,EAAwB;AACtBQ,QAAAA,OAAO,IAAIC,MAAM,CAACC,YAAP,CAAoB,KAAKX,IAAL,CAAU,KAAKE,GAAL,EAAV,CAApB,CAAX;AACD;;AAED,cAAQO,OAAR;AACE,aAAK,MAAL;AACE;AACA,eAAKG,KAAL,GAAa,KAAKJ,UAAL,EAAb;AACA,eAAKK,MAAL,GAAc,KAAKL,UAAL,EAAd;AACA,eAAKM,IAAL,GAAY,KAAKd,IAAL,CAAU,KAAKE,GAAL,EAAV,CAAZ;AACA,eAAKa,SAAL,GAAiB,KAAKf,IAAL,CAAU,KAAKE,GAAL,EAAV,CAAjB;AACA,eAAKc,iBAAL,GAAyB,KAAKhB,IAAL,CAAU,KAAKE,GAAL,EAAV,CAAzB;AACA,eAAKe,YAAL,GAAoB,KAAKjB,IAAL,CAAU,KAAKE,GAAL,EAAV,CAApB;AACA,eAAKgB,eAAL,GAAuB,KAAKlB,IAAL,CAAU,KAAKE,GAAL,EAAV,CAAvB;AACA;;AAEF,aAAK,MAAL;AACE,eAAKC,OAAL,GAAe,KAAKgB,IAAL,CAAUZ,SAAV,CAAf;AACA;;AAEF,aAAK,MAAL;AACE,eAAKN,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGM,SAAhB,EAA2BN,CAAC,EAA5B,EAAgC;AAC9B,iBAAKG,OAAL,CAAagB,IAAb,CAAkB,KAAKpB,IAAL,CAAU,KAAKE,GAAL,EAAV,CAAlB;AACD;;AACD;;AAEF,aAAK,MAAL;AACE;AACA;AACA,eAAKG,YAAL,GAAoB,EAApB;;AACA,kBAAQ,KAAKU,SAAb;AACE,iBAAK,CAAL;AACE;AACA;AACA;AACA;AACA,mBAAKV,YAAL,CAAkBgB,OAAlB,GAA4B,KAAKF,IAAL,CAAUZ,SAAV,CAA5B;AACA,kBAAIe,KAAK,GAAG,MAAM,KAAKjB,YAAL,CAAkBgB,OAAlB,CAA0BE,MAA5C;;AACA,kBAAID,KAAK,GAAG,CAAZ,EAAe;AACb,qBAAKrB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGqB,KAAhB,EAAuBrB,CAAC,EAAxB,EAA4B;AAC1B,uBAAKI,YAAL,CAAkBgB,OAAlB,CAA0BD,IAA1B,CAA+B,GAA/B;AACD;AACF;;AACD;;AACF,iBAAK,CAAL;AACE;AACA;AACA,mBAAKf,YAAL,CAAkBmB,SAAlB,GAA8B,KAAKL,IAAL,CAAUZ,SAAV,EAAqB,CAArB,CAA9B;AACA;;AACF,iBAAK,CAAL;AACE;AACA,mBAAKF,YAAL,CAAkBoB,GAAlB,GAAwB,KAAKN,IAAL,CAAUZ,SAAV,CAAxB;AACA;AAtBJ;;AAwBA;;AAEF,aAAK,MAAL;AACE,cAAID,IAAI,GAAG,KAAKa,IAAL,CAAUZ,SAAV,CAAX;AACA,cAAImB,KAAK,GAAGpB,IAAI,CAACqB,OAAL,CAAa,CAAb,CAAZ;AACA,cAAIC,GAAG,GAAGlB,MAAM,CAACC,YAAP,CAAoBkB,KAApB,CAA0BnB,MAA1B,EAAkCJ,IAAI,CAACwB,KAAL,CAAW,CAAX,EAAcJ,KAAd,CAAlC,CAAV;AACA,eAAKpB,IAAL,CAAUsB,GAAV,IAAiBlB,MAAM,CAACC,YAAP,CAAoBkB,KAApB,CACfnB,MADe,EAEfJ,IAAI,CAACwB,KAAL,CAAWJ,KAAK,GAAG,CAAnB,CAFe,CAAjB;AAIA;;AAEF,aAAK,MAAL;AACE;AACA,kBAAQ,KAAKX,SAAb;AACE,iBAAK,CAAL;AACA,iBAAK,CAAL;AACA,iBAAK,CAAL;AACE,mBAAKgB,MAAL,GAAc,CAAd;AACA;;AACF,iBAAK,CAAL;AACA,iBAAK,CAAL;AACE,mBAAKA,MAAL,GAAc,CAAd;AACA;AATJ;;AAYA,eAAKC,eAAL,GAAuB,CAAC,CAAD,EAAI,CAAJ,EAAOC,QAAP,CAAgB,KAAKlB,SAArB,CAAvB;AACA,cAAIgB,MAAM,GAAG,KAAKA,MAAL,IAAe,KAAKC,eAAL,GAAuB,CAAvB,GAA2B,CAA1C,CAAb;AACA,eAAKE,cAAL,GAAsB,KAAKpB,IAAL,GAAYiB,MAAlC;;AAEA,kBAAQ,KAAKA,MAAb;AACE,iBAAK,CAAL;AACE,mBAAKI,UAAL,GAAkB,YAAlB;AACA;;AACF,iBAAK,CAAL;AACE,mBAAKA,UAAL,GAAkB,WAAlB;AACA;AANJ;;AASA,eAAK/B,OAAL,GAAe,IAAIgC,MAAJ,CAAW,KAAKhC,OAAhB,CAAf;AACA;AACA;;AAEF;AACE;AACA,eAAKF,GAAL,IAAYK,SAAZ;AA/FJ;;AAkGA,WAAKL,GAAL,IAAY,CAAZ,CAzGW,CAyGI;;AAEf,UAAI,KAAKA,GAAL,GAAW,KAAKF,IAAL,CAAUuB,MAAzB,EAAiC;AAC/B,cAAM,IAAIc,KAAJ,CAAU,gCAAV,CAAN;AACD;AACF;AACF;;AAEDlB,EAAAA,IAAI,CAACmB,KAAD,EAAQ;AACV,UAAMC,MAAM,GAAG,IAAIC,KAAJ,CAAUF,KAAV,CAAf;;AACA,SAAK,IAAIrC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqC,KAApB,EAA2BrC,CAAC,EAA5B,EAAgC;AAC9BsC,MAAAA,MAAM,CAACtC,CAAD,CAAN,GAAY,KAAKD,IAAL,CAAU,KAAKE,GAAL,EAAV,CAAZ;AACD;;AACD,WAAOqC,MAAP;AACD;;AAED/B,EAAAA,UAAU,GAAG;AACX,UAAMiC,EAAE,GAAG,KAAKzC,IAAL,CAAU,KAAKE,GAAL,EAAV,KAAyB,EAApC;AACA,UAAMwC,EAAE,GAAG,KAAK1C,IAAL,CAAU,KAAKE,GAAL,EAAV,KAAyB,EAApC;AACA,UAAMyC,EAAE,GAAG,KAAK3C,IAAL,CAAU,KAAKE,GAAL,EAAV,KAAyB,CAApC;AACA,UAAM0C,EAAE,GAAG,KAAK5C,IAAL,CAAU,KAAKE,GAAL,EAAV,CAAX;AACA,WAAOuC,EAAE,GAAGC,EAAL,GAAUC,EAAV,GAAeC,EAAtB;AACD;;AAEDC,EAAAA,UAAU,GAAG;AACX,UAAMJ,EAAE,GAAG,KAAKzC,IAAL,CAAU,KAAKE,GAAL,EAAV,KAAyB,CAApC;AACA,UAAMwC,EAAE,GAAG,KAAK1C,IAAL,CAAU,KAAKE,GAAL,EAAV,CAAX;AACA,WAAOuC,EAAE,GAAGC,EAAZ;AACD;;AAEDI,EAAAA,YAAY,CAACvD,EAAD,EAAK;AACf,WAAON,IAAI,CAAC8D,OAAL,CAAa,KAAK3C,OAAlB,EAA2B,CAACX,GAAD,EAAMO,IAAN,KAAe;AAC/C,UAAIP,GAAJ,EAAS;AACP,cAAMA,GAAN;AACD;;AAH8C,YAKvCmB,KALuC,GAKrB,IALqB,CAKvCA,KALuC;AAAA,YAKhCC,MALgC,GAKrB,IALqB,CAKhCA,MALgC;AAM/C,YAAMmC,UAAU,GAAG,KAAKd,cAAL,GAAsB,CAAzC;AAEA,YAAMtC,MAAM,GAAG,IAAIwC,MAAJ,CAAWxB,KAAK,GAAGC,MAAR,GAAiBmC,UAA5B,CAAf;AAR+C,YASvCzB,MATuC,GAS5BvB,IAT4B,CASvCuB,MATuC;AAU/C,UAAIrB,GAAG,GAAG,CAAV;;AAEA,eAAS+C,IAAT,CAAcC,EAAd,EAAkBC,EAAlB,EAAsBC,EAAtB,EAA0BC,EAA1B,EAA8BC,UAAU,GAAG,KAA3C,EAAkD;AAChD,cAAMC,CAAC,GAAGC,IAAI,CAACC,IAAL,CAAU,CAAC7C,KAAK,GAAGsC,EAAT,IAAeE,EAAzB,CAAV;AACA,cAAMM,CAAC,GAAGF,IAAI,CAACC,IAAL,CAAU,CAAC5C,MAAM,GAAGsC,EAAV,IAAgBE,EAA1B,CAAV;AACA,cAAMM,cAAc,GAAGX,UAAU,GAAGO,CAApC;AACA,cAAMK,MAAM,GAAGN,UAAU,GAAG1D,MAAH,GAAY,IAAIwC,MAAJ,CAAWuB,cAAc,GAAGD,CAA5B,CAArC;AACA,YAAIG,GAAG,GAAG,CAAV;AACA,YAAIC,CAAC,GAAG,CAAR;;AACA,eAAOD,GAAG,GAAGH,CAAN,IAAWxD,GAAG,GAAGqB,MAAxB,EAAgC;AAC9B,cAAIwC,IAAJ,EAAUC,GAAV,EAAe/D,CAAf,EAAkBgE,IAAlB,EAAwBC,KAAxB;;AACA,kBAAQlE,IAAI,CAACE,GAAG,EAAJ,CAAZ;AACE,iBAAK,CAAL;AAAQ;AACN,mBAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0D,cAAhB,EAAgC1D,CAAC,EAAjC,EAAqC;AACnC2D,gBAAAA,MAAM,CAACE,CAAC,EAAF,CAAN,GAAc9D,IAAI,CAACE,GAAG,EAAJ,CAAlB;AACD;;AACD;;AAEF,iBAAK,CAAL;AAAQ;AACN,mBAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0D,cAAhB,EAAgC1D,CAAC,EAAjC,EAAqC;AACnC8D,gBAAAA,IAAI,GAAG/D,IAAI,CAACE,GAAG,EAAJ,CAAX;AACA+D,gBAAAA,IAAI,GAAGhE,CAAC,GAAG+C,UAAJ,GAAiB,CAAjB,GAAqBY,MAAM,CAACE,CAAC,GAAGd,UAAL,CAAlC;AACAY,gBAAAA,MAAM,CAACE,CAAC,EAAF,CAAN,GAAc,CAACC,IAAI,GAAGE,IAAR,IAAgB,GAA9B;AACD;;AACD;;AAEF,iBAAK,CAAL;AAAQ;AACN,mBAAKhE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0D,cAAhB,EAAgC1D,CAAC,EAAjC,EAAqC;AACnC8D,gBAAAA,IAAI,GAAG/D,IAAI,CAACE,GAAG,EAAJ,CAAX;AACA8D,gBAAAA,GAAG,GAAG,CAAC/D,CAAC,GAAIA,CAAC,GAAG+C,UAAV,IAAyBA,UAA/B;AACAkB,gBAAAA,KAAK,GACHL,GAAG,IACHD,MAAM,CACJ,CAACC,GAAG,GAAG,CAAP,IAAYF,cAAZ,GACEK,GAAG,GAAGhB,UADR,GAEG/C,CAAC,GAAG+C,UAHH,CAFR;AAOAY,gBAAAA,MAAM,CAACE,CAAC,EAAF,CAAN,GAAc,CAACI,KAAK,GAAGH,IAAT,IAAiB,GAA/B;AACD;;AACD;;AAEF,iBAAK,CAAL;AAAQ;AACN,mBAAK9D,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0D,cAAhB,EAAgC1D,CAAC,EAAjC,EAAqC;AACnC8D,gBAAAA,IAAI,GAAG/D,IAAI,CAACE,GAAG,EAAJ,CAAX;AACA8D,gBAAAA,GAAG,GAAG,CAAC/D,CAAC,GAAIA,CAAC,GAAG+C,UAAV,IAAyBA,UAA/B;AACAiB,gBAAAA,IAAI,GAAGhE,CAAC,GAAG+C,UAAJ,GAAiB,CAAjB,GAAqBY,MAAM,CAACE,CAAC,GAAGd,UAAL,CAAlC;AACAkB,gBAAAA,KAAK,GACHL,GAAG,IACHD,MAAM,CACJ,CAACC,GAAG,GAAG,CAAP,IAAYF,cAAZ,GACEK,GAAG,GAAGhB,UADR,GAEG/C,CAAC,GAAG+C,UAHH,CAFR;AAOAY,gBAAAA,MAAM,CAACE,CAAC,EAAF,CAAN,GAAc,CAACC,IAAI,GAAGP,IAAI,CAACW,KAAL,CAAW,CAACF,IAAI,GAAGC,KAAR,IAAiB,CAA5B,CAAR,IAA0C,GAAxD;AACD;;AACD;;AAEF,iBAAK,CAAL;AAAQ;AACN,mBAAKjE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG0D,cAAhB,EAAgC1D,CAAC,EAAjC,EAAqC;AACnC,oBAAImE,KAAJ,EAAWC,SAAX;AACAN,gBAAAA,IAAI,GAAG/D,IAAI,CAACE,GAAG,EAAJ,CAAX;AACA8D,gBAAAA,GAAG,GAAG,CAAC/D,CAAC,GAAIA,CAAC,GAAG+C,UAAV,IAAyBA,UAA/B;AACAiB,gBAAAA,IAAI,GAAGhE,CAAC,GAAG+C,UAAJ,GAAiB,CAAjB,GAAqBY,MAAM,CAACE,CAAC,GAAGd,UAAL,CAAlC;;AAEA,oBAAIa,GAAG,KAAK,CAAZ,EAAe;AACbK,kBAAAA,KAAK,GAAGG,SAAS,GAAG,CAApB;AACD,iBAFD,MAEO;AACLH,kBAAAA,KAAK,GACHN,MAAM,CACJ,CAACC,GAAG,GAAG,CAAP,IAAYF,cAAZ,GACEK,GAAG,GAAGhB,UADR,GAEG/C,CAAC,GAAG+C,UAHH,CADR;AAMAqB,kBAAAA,SAAS,GACPL,GAAG,IACHJ,MAAM,CACJ,CAACC,GAAG,GAAG,CAAP,IAAYF,cAAZ,GACE,CAACK,GAAG,GAAG,CAAP,IAAYhB,UADd,GAEG/C,CAAC,GAAG+C,UAHH,CAFR;AAOD;;AAED,sBAAMsB,CAAC,GAAGL,IAAI,GAAGC,KAAP,GAAeG,SAAzB;AACA,sBAAME,EAAE,GAAGf,IAAI,CAACgB,GAAL,CAASF,CAAC,GAAGL,IAAb,CAAX;AACA,sBAAMQ,EAAE,GAAGjB,IAAI,CAACgB,GAAL,CAASF,CAAC,GAAGJ,KAAb,CAAX;AACA,sBAAMQ,EAAE,GAAGlB,IAAI,CAACgB,GAAL,CAASF,CAAC,GAAGD,SAAb,CAAX;;AAEA,oBAAIE,EAAE,IAAIE,EAAN,IAAYF,EAAE,IAAIG,EAAtB,EAA0B;AACxBN,kBAAAA,KAAK,GAAGH,IAAR;AACD,iBAFD,MAEO,IAAIQ,EAAE,IAAIC,EAAV,EAAc;AACnBN,kBAAAA,KAAK,GAAGF,KAAR;AACD,iBAFM,MAEA;AACLE,kBAAAA,KAAK,GAAGC,SAAR;AACD;;AAEDT,gBAAAA,MAAM,CAACE,CAAC,EAAF,CAAN,GAAc,CAACC,IAAI,GAAGK,KAAR,IAAiB,GAA/B;AACD;;AACD;;AAEF;AACE,oBAAM,IAAI/B,KAAJ,CAAW,6BAA4BrC,IAAI,CAACE,GAAG,GAAG,CAAP,CAAU,EAArD,CAAN;AAzFJ;;AA4FA,cAAI,CAACoD,UAAL,EAAiB;AACf,gBAAIqB,SAAS,GAAG,CAAC,CAACxB,EAAE,GAAGU,GAAG,GAAGR,EAAZ,IAAkBzC,KAAlB,GAA0BsC,EAA3B,IAAiCF,UAAjD;AACA,gBAAI4B,SAAS,GAAGf,GAAG,GAAGF,cAAtB;;AACA,iBAAK1D,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGsD,CAAhB,EAAmBtD,CAAC,EAApB,EAAwB;AACtB,mBAAK,IAAI4E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7B,UAApB,EAAgC6B,CAAC,EAAjC,EACEjF,MAAM,CAAC+E,SAAS,EAAV,CAAN,GAAsBf,MAAM,CAACgB,SAAS,EAAV,CAA5B;;AACFD,cAAAA,SAAS,IAAI,CAACvB,EAAE,GAAG,CAAN,IAAWJ,UAAxB;AACD;AACF;;AAEDa,UAAAA,GAAG;AACJ;AACF;;AAED,UAAI,KAAK3C,eAAL,KAAyB,CAA7B,EAAgC;AAC9B;;;;;;;;;;AAUA+B,QAAAA,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAJ,CAX8B,CAWZ;;AAClBA,QAAAA,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAJ,CAZ8B,CAYZ;;AAClBA,QAAAA,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAJ,CAb8B,CAaZ;;AAClBA,QAAAA,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAJ,CAd8B,CAcZ;;AAClBA,QAAAA,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAJ,CAf8B,CAeZ;;AAClBA,QAAAA,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAJ,CAhB8B,CAgBZ;;AAClBA,QAAAA,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAJ,CAjB8B,CAiBZ;AACnB,OAlBD,MAkBO;AACLA,QAAAA,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,IAAb,CAAJ;AACD;;AAED,aAAO1D,EAAE,CAACK,MAAD,CAAT;AACD,KAtJM,CAAP;AAuJD;;AAEDkF,EAAAA,aAAa,GAAG;AAAA,UACN3E,OADM,GACM,IADN,CACNA,OADM;AAAA,UAENoB,MAFM,GAEKpB,OAFL,CAENoB,MAFM;AAGd,UAAMlB,YAAY,GAAG,KAAKA,YAAL,CAAkBgB,OAAlB,IAA6B,EAAlD;AACA,UAAM0D,GAAG,GAAG,IAAI3C,MAAJ,CAAW/B,YAAY,CAACkB,MAAb,GAAsBA,MAAjC,CAAZ;AACA,QAAIrB,GAAG,GAAG,CAAV;AACA,QAAI4D,CAAC,GAAG,CAAR;;AAEA,SAAK,IAAI7D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsB,MAApB,EAA4BtB,CAAC,IAAI,CAAjC,EAAoC;AAClC,UAAIgE,IAAJ;AACAc,MAAAA,GAAG,CAAC7E,GAAG,EAAJ,CAAH,GAAaC,OAAO,CAACF,CAAD,CAApB;AACA8E,MAAAA,GAAG,CAAC7E,GAAG,EAAJ,CAAH,GAAaC,OAAO,CAACF,CAAC,GAAG,CAAL,CAApB;AACA8E,MAAAA,GAAG,CAAC7E,GAAG,EAAJ,CAAH,GAAaC,OAAO,CAACF,CAAC,GAAG,CAAL,CAApB;AACA8E,MAAAA,GAAG,CAAC7E,GAAG,EAAJ,CAAH,GAAa,CAAC+D,IAAI,GAAG5D,YAAY,CAACyD,CAAC,EAAF,CAApB,KAA8B,IAA9B,GAAqCG,IAArC,GAA4C,GAAzD;AACD;;AAED,WAAOc,GAAP;AACD;;AAEDC,EAAAA,eAAe,CAACC,SAAD,EAAYrF,MAAZ,EAAoB;AACjC,QAAIiF,CAAJ,EAAOK,CAAP;AADiC,QAE3BnD,MAF2B,GAEhB,IAFgB,CAE3BA,MAF2B;AAGjC,QAAI5B,OAAO,GAAG,IAAd;AACA,QAAIgF,KAAK,GAAG,KAAKnD,eAAjB;;AAEA,QAAI,KAAK7B,OAAL,CAAaoB,MAAjB,EAAyB;AACvBpB,MAAAA,OAAO,GACL,KAAKiF,eAAL,KAAyB,KAAKA,eAAL,GAAuB,KAAKN,aAAL,EAAhD,CADF;AAEA/C,MAAAA,MAAM,GAAG,CAAT;AACAoD,MAAAA,KAAK,GAAG,IAAR;AACD;;AAED,UAAMnF,IAAI,GAAGiF,SAAS,CAACjF,IAAV,IAAkBiF,SAA/B;AAbiC,UAczB1D,MAdyB,GAcdvB,IAdc,CAczBuB,MAdyB;AAejC,UAAM8D,KAAK,GAAGlF,OAAO,IAAIP,MAAzB;AACA,QAAIK,CAAC,GAAI4E,CAAC,GAAG,CAAb;;AAEA,QAAI9C,MAAM,KAAK,CAAf,EAAkB;AAChB,aAAO9B,CAAC,GAAGsB,MAAX,EAAmB;AACjB2D,QAAAA,CAAC,GAAG/E,OAAO,GAAGP,MAAM,CAACK,CAAC,GAAG,CAAL,CAAN,GAAgB,CAAnB,GAAuB4E,CAAlC;AACA,cAAMS,CAAC,GAAGD,KAAK,CAACH,CAAC,EAAF,CAAf;AACAlF,QAAAA,IAAI,CAACC,CAAC,EAAF,CAAJ,GAAYqF,CAAZ;AACAtF,QAAAA,IAAI,CAACC,CAAC,EAAF,CAAJ,GAAYqF,CAAZ;AACAtF,QAAAA,IAAI,CAACC,CAAC,EAAF,CAAJ,GAAYqF,CAAZ;AACAtF,QAAAA,IAAI,CAACC,CAAC,EAAF,CAAJ,GAAYkF,KAAK,GAAGE,KAAK,CAACH,CAAC,EAAF,CAAR,GAAgB,GAAjC;AACAL,QAAAA,CAAC,GAAGK,CAAJ;AACD;AACF,KAVD,MAUO;AACL,aAAOjF,CAAC,GAAGsB,MAAX,EAAmB;AACjB2D,QAAAA,CAAC,GAAG/E,OAAO,GAAGP,MAAM,CAACK,CAAC,GAAG,CAAL,CAAN,GAAgB,CAAnB,GAAuB4E,CAAlC;AACA7E,QAAAA,IAAI,CAACC,CAAC,EAAF,CAAJ,GAAYoF,KAAK,CAACH,CAAC,EAAF,CAAjB;AACAlF,QAAAA,IAAI,CAACC,CAAC,EAAF,CAAJ,GAAYoF,KAAK,CAACH,CAAC,EAAF,CAAjB;AACAlF,QAAAA,IAAI,CAACC,CAAC,EAAF,CAAJ,GAAYoF,KAAK,CAACH,CAAC,EAAF,CAAjB;AACAlF,QAAAA,IAAI,CAACC,CAAC,EAAF,CAAJ,GAAYkF,KAAK,GAAGE,KAAK,CAACH,CAAC,EAAF,CAAR,GAAgB,GAAjC;AACAL,QAAAA,CAAC,GAAGK,CAAJ;AACD;AACF;AACF;;AAED7F,EAAAA,MAAM,CAACE,EAAD,EAAK;AACT,UAAMwF,GAAG,GAAG,IAAI3C,MAAJ,CAAW,KAAKxB,KAAL,GAAa,KAAKC,MAAlB,GAA2B,CAAtC,CAAZ;AACA,WAAO,KAAKiC,YAAL,CAAkBlD,MAAM,IAAI;AACjC,WAAKoF,eAAL,CAAqBD,GAArB,EAA0BnF,MAA1B;AACA,aAAOL,EAAE,CAACwF,GAAD,CAAT;AACD,KAHM,CAAP;AAID;;AAzXwB,CAA3B","sourcesContent":["/*\n * MIT LICENSE\n * Copyright (c) 2011 Devon Govett\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nmodule.exports = class PNG {\n  static decode(path, fn) {\n    return fs.readFile(path, function(err, file) {\n      const png = new PNG(file);\n      return png.decode(pixels => fn(pixels));\n    });\n  }\n\n  static load(path) {\n    const file = fs.readFileSync(path);\n    return new PNG(file);\n  }\n\n  constructor(data) {\n    let i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      const chunkSize = this.readUInt32();\n      let section = '';\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n              break;\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(\n            String,\n            text.slice(index + 1)\n          );\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n\n  read(bytes) {\n    const result = new Array(bytes);\n    for (let i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n    return result;\n  }\n\n  readUInt32() {\n    const b1 = this.data[this.pos++] << 24;\n    const b2 = this.data[this.pos++] << 16;\n    const b3 = this.data[this.pos++] << 8;\n    const b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  }\n\n  readUInt16() {\n    const b1 = this.data[this.pos++] << 8;\n    const b2 = this.data[this.pos++];\n    return b1 | b2;\n  }\n\n  decodePixels(fn) {\n    return zlib.inflate(this.imgData, (err, data) => {\n      if (err) {\n        throw err;\n      }\n\n      const { width, height } = this;\n      const pixelBytes = this.pixelBitlength / 8;\n\n      const pixels = new Buffer(width * height * pixelBytes);\n      const { length } = data;\n      let pos = 0;\n\n      function pass(x0, y0, dx, dy, singlePass = false) {\n        const w = Math.ceil((width - x0) / dx);\n        const h = Math.ceil((height - y0) / dy);\n        const scanlineLength = pixelBytes * w;\n        const buffer = singlePass ? pixels : new Buffer(scanlineLength * h);\n        let row = 0;\n        let c = 0;\n        while (row < h && pos < length) {\n          var byte, col, i, left, upper;\n          switch (data[pos++]) {\n            case 0: // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n              break;\n\n            case 1: // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n              break;\n\n            case 2: // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                upper =\n                  row &&\n                  buffer[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                buffer[c++] = (upper + byte) % 256;\n              }\n              break;\n\n            case 3: // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper =\n                  row &&\n                  buffer[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n              break;\n\n            case 4: // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper =\n                    buffer[\n                      (row - 1) * scanlineLength +\n                        col * pixelBytes +\n                        (i % pixelBytes)\n                    ];\n                  upperLeft =\n                    col &&\n                    buffer[\n                      (row - 1) * scanlineLength +\n                        (col - 1) * pixelBytes +\n                        (i % pixelBytes)\n                    ];\n                }\n\n                const p = left + upper - upperLeft;\n                const pa = Math.abs(p - left);\n                const pb = Math.abs(p - upper);\n                const pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                buffer[c++] = (byte + paeth) % 256;\n              }\n              break;\n\n            default:\n              throw new Error(`Invalid filter algorithm: ${data[pos - 1]}`);\n          }\n\n          if (!singlePass) {\n            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            let bufferPos = row * scanlineLength;\n            for (i = 0; i < w; i++) {\n              for (let j = 0; j < pixelBytes; j++)\n                pixels[pixelsPos++] = buffer[bufferPos++];\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n\n          row++;\n        }\n      }\n\n      if (this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n        pass(4, 0, 8, 8); // 2\n        pass(0, 4, 4, 8); // 3\n        pass(2, 0, 4, 4); // 4\n        pass(0, 2, 2, 4); // 5\n        pass(1, 0, 2, 2); // 6\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n\n      return fn(pixels);\n    });\n  }\n\n  decodePalette() {\n    const { palette } = this;\n    const { length } = palette;\n    const transparency = this.transparency.indexed || [];\n    const ret = new Buffer(transparency.length + length);\n    let pos = 0;\n    let c = 0;\n\n    for (let i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n\n    return ret;\n  }\n\n  copyToImageData(imageData, pixels) {\n    let j, k;\n    let { colors } = this;\n    let palette = null;\n    let alpha = this.hasAlphaChannel;\n\n    if (this.palette.length) {\n      palette =\n        this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n\n    const data = imageData.data || imageData;\n    const { length } = data;\n    const input = palette || pixels;\n    let i = (j = 0);\n\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        const v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  }\n\n  decode(fn) {\n    const ret = new Buffer(this.width * this.height * 4);\n    return this.decodePixels(pixels => {\n      this.copyToImageData(ret, pixels);\n      return fn(ret);\n    });\n  }\n};\n"]},"metadata":{},"sourceType":"script"}