{"ast":null,"code":"let AI, AL, BA, BK, CB, CJ, CR, ID, LF, NL, NS, SA, SG, SP, WJ, XX;\n\nconst UnicodeTrie = require('unicode-trie');\n\nconst fs = require('fs');\n\nconst base64 = require('base64-js');\n\nvar _require = require('./classes');\n\nBK = _require.BK;\nCR = _require.CR;\nLF = _require.LF;\nNL = _require.NL;\nCB = _require.CB;\nBA = _require.BA;\nSP = _require.SP;\nWJ = _require.WJ;\nSP = _require.SP;\nBK = _require.BK;\nLF = _require.LF;\nNL = _require.NL;\nAI = _require.AI;\nAL = _require.AL;\nSA = _require.SA;\nSG = _require.SG;\nXX = _require.XX;\nCJ = _require.CJ;\nID = _require.ID;\nNS = _require.NS;\n\nconst _require2 = require('./pairs'),\n      DI_BRK = _require2.DI_BRK,\n      IN_BRK = _require2.IN_BRK,\n      CI_BRK = _require2.CI_BRK,\n      CP_BRK = _require2.CP_BRK,\n      PR_BRK = _require2.PR_BRK,\n      pairTable = _require2.pairTable;\n\nconst data = base64.toByteArray(fs.readFileSync(__dirname + '/classes.trie', 'base64'));\nconst classTrie = new UnicodeTrie(data);\n\nconst mapClass = function (c) {\n  switch (c) {\n    case AI:\n      return AL;\n\n    case SA:\n    case SG:\n    case XX:\n      return AL;\n\n    case CJ:\n      return NS;\n\n    default:\n      return c;\n  }\n};\n\nconst mapFirst = function (c) {\n  switch (c) {\n    case LF:\n    case NL:\n      return BK;\n\n    case CB:\n      return BA;\n\n    case SP:\n      return WJ;\n\n    default:\n      return c;\n  }\n};\n\nclass Break {\n  constructor(position, required = false) {\n    this.position = position;\n    this.required = required;\n  }\n\n}\n\n;\n\nclass LineBreaker {\n  constructor(string) {\n    this.string = string;\n    this.pos = 0;\n    this.lastPos = 0;\n    this.curClass = null;\n    this.nextClass = null;\n  }\n\n  nextCodePoint() {\n    const code = this.string.charCodeAt(this.pos++);\n    const next = this.string.charCodeAt(this.pos); // If a surrogate pair\n\n    if (0xd800 <= code && code <= 0xdbff && 0xdc00 <= next && next <= 0xdfff) {\n      this.pos++;\n      return (code - 0xd800) * 0x400 + (next - 0xdc00) + 0x10000;\n    }\n\n    return code;\n  }\n\n  nextCharClass() {\n    return mapClass(classTrie.get(this.nextCodePoint()));\n  }\n\n  nextBreak() {\n    // get the first char if we're at the beginning of the string\n    if (this.curClass == null) {\n      this.curClass = mapFirst(this.nextCharClass());\n    }\n\n    while (this.pos < this.string.length) {\n      this.lastPos = this.pos;\n      const lastClass = this.nextClass;\n      this.nextClass = this.nextCharClass(); // explicit newline\n\n      if (this.curClass === BK || this.curClass === CR && this.nextClass !== LF) {\n        this.curClass = mapFirst(mapClass(this.nextClass));\n        return new Break(this.lastPos, true);\n      } // handle classes not handled by the pair table\n\n\n      let cur;\n\n      switch (this.nextClass) {\n        case SP:\n          cur = this.curClass;\n          break;\n\n        case BK:\n        case LF:\n        case NL:\n          cur = BK;\n          break;\n\n        case CR:\n          cur = CR;\n          break;\n\n        case CB:\n          cur = BA;\n          break;\n      }\n\n      if (cur != null) {\n        this.curClass = cur;\n\n        if (this.nextClass === CB) {\n          return new Break(this.lastPos);\n        }\n\n        continue;\n      } // if not handled already, use the pair table\n\n\n      let shouldBreak = false;\n\n      switch (pairTable[this.curClass][this.nextClass]) {\n        case DI_BRK:\n          // Direct break\n          shouldBreak = true;\n          break;\n\n        case IN_BRK:\n          // possible indirect break\n          shouldBreak = lastClass === SP;\n          break;\n\n        case CI_BRK:\n          shouldBreak = lastClass === SP;\n\n          if (!shouldBreak) {\n            continue;\n          }\n\n          break;\n\n        case CP_BRK:\n          // prohibited for combining marks\n          if (lastClass !== SP) {\n            continue;\n          }\n\n          break;\n      }\n\n      this.curClass = this.nextClass;\n\n      if (shouldBreak) {\n        return new Break(this.lastPos);\n      }\n    }\n\n    if (this.pos >= this.string.length) {\n      if (this.lastPos < this.string.length) {\n        this.lastPos = this.string.length;\n        return new Break(this.string.length);\n      } else {\n        return null;\n      }\n    }\n  }\n\n}\n\n;\nmodule.exports = LineBreaker;","map":{"version":3,"sources":["/Users/pedrojacob/Downloads/AMR/websites/office_records/ENT_EMR/frontend/node_modules/linebreak/src/linebreaker.js"],"names":["AI","AL","BA","BK","CB","CJ","CR","ID","LF","NL","NS","SA","SG","SP","WJ","XX","UnicodeTrie","require","fs","base64","DI_BRK","IN_BRK","CI_BRK","CP_BRK","PR_BRK","pairTable","data","toByteArray","readFileSync","__dirname","classTrie","mapClass","c","mapFirst","Break","constructor","position","required","LineBreaker","string","pos","lastPos","curClass","nextClass","nextCodePoint","code","charCodeAt","next","nextCharClass","get","nextBreak","length","lastClass","cur","shouldBreak","module","exports"],"mappings":"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","sourcesContent":["let AI, AL, BA, BK, CB, CJ, CR, ID, LF, NL, NS, SA, SG, SP, WJ, XX;\nconst UnicodeTrie = require('unicode-trie');\nconst fs = require('fs');\nconst base64 = require('base64-js');\n({BK, CR, LF, NL, CB, BA, SP, WJ, SP, BK, LF, NL, AI, AL, SA, SG, XX, CJ, ID, NS} = require('./classes'));\nconst {DI_BRK, IN_BRK, CI_BRK, CP_BRK, PR_BRK, pairTable} = require('./pairs');\n\nconst data = base64.toByteArray(fs.readFileSync(__dirname + '/classes.trie', 'base64'));\nconst classTrie = new UnicodeTrie(data);\n\nconst mapClass = function(c) {\n  switch (c) {\n    case AI:         return AL;\n    case SA: case SG: case XX: return AL;\n    case CJ:         return NS;\n    default:            return c;\n  }\n};\n    \nconst mapFirst = function(c) {\n  switch (c) {\n    case LF: case NL: return BK;\n    case CB:     return BA;\n    case SP:     return WJ;\n    default:        return c;\n  }\n};\n\nclass Break {\n  constructor(position, required = false) {\n    this.position = position;    \n    this.required = required;\n  }\n};\n  \nclass LineBreaker {    \n  constructor(string) {\n    this.string = string;\n    this.pos = 0;\n    this.lastPos = 0;\n    this.curClass = null;\n    this.nextClass = null;\n  }\n  \n  nextCodePoint() {\n    const code = this.string.charCodeAt(this.pos++);\n    const next = this.string.charCodeAt(this.pos);\n  \n    // If a surrogate pair\n    if ((0xd800 <= code && code <= 0xdbff) && (0xdc00 <= next && next <= 0xdfff)) {\n      this.pos++;\n      return ((code - 0xd800) * 0x400) + (next - 0xdc00) + 0x10000;\n    }\n    \n    return code;\n  }\n      \n  nextCharClass() {\n    return mapClass(classTrie.get(this.nextCodePoint()));\n  }\n  \n  nextBreak() {    \n    // get the first char if we're at the beginning of the string\n    if (this.curClass == null) { this.curClass = mapFirst(this.nextCharClass()); }\n  \n    while (this.pos < this.string.length) {\n      this.lastPos = this.pos;\n      const lastClass = this.nextClass;\n      this.nextClass = this.nextCharClass();\n    \n      // explicit newline\n      if ((this.curClass === BK) || ((this.curClass === CR) && (this.nextClass !== LF))) {\n        this.curClass = mapFirst(mapClass(this.nextClass));\n        return new Break(this.lastPos, true);\n      }\n    \n      // handle classes not handled by the pair table\n      let cur\n      switch (this.nextClass) {\n        case SP:         cur = this.curClass; break;\n        case BK: case LF: case NL: cur = BK; break;\n        case CR:         cur = CR; break;\n        case CB:         cur = BA; break;\n      }\n      \n      if (cur != null) {\n        this.curClass = cur;\n        if (this.nextClass === CB) { return new Break(this.lastPos); }\n        continue;\n      }\n    \n      // if not handled already, use the pair table\n      let shouldBreak = false;\n      switch (pairTable[this.curClass][this.nextClass]) {\n        case DI_BRK: // Direct break\n          shouldBreak = true;\n          break;\n        \n        case IN_BRK: // possible indirect break\n          shouldBreak = lastClass === SP;\n          break;\n          \n        case CI_BRK:\n          shouldBreak = lastClass === SP;\n          if (!shouldBreak) { continue; }\n          break;\n          \n        case CP_BRK: // prohibited for combining marks\n          if (lastClass !== SP) { continue; }\n          break;\n      }\n        \n      this.curClass = this.nextClass;\n      if (shouldBreak) {\n        return new Break(this.lastPos);\n      }\n    }\n    \n    if (this.pos >= this.string.length) {\n      if (this.lastPos < this.string.length) {\n        this.lastPos = this.string.length;\n        return new Break(this.string.length);\n      } else {\n        return null;\n      }\n    }\n  }\n};\n          \nmodule.exports = LineBreaker;\n"]},"metadata":{},"sourceType":"script"}